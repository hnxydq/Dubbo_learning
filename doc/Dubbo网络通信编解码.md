## Dubbo网络通信-编解码

### Dubbo远程通讯协议头定义

![dubbo_protocol_header](img/dubbo_protocol_header.jpg)



 **1.为什么Dubbo要自己增加协议扩展？**

----为了解决TCP/IP粘包和拆包的问题。

所谓粘包和拆包，就是一个完整的业务数据可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送。 

**2.TCP为什么会出现粘包与拆包？**

TCP是以流动的方式传输数据，传输的最小单位为一个报文段（segment）。Tcp Header中有个Options标识位，常见的标识为mss(Maximum Segment Size)指的是，连接层每次传输的数据有个最大限制MTU(Maximum Transmission Unit)，一般是1500比特，超过这个量要分成多个报文段，mss则是这个最大限制减去TCP的header，光是要传输的数据的大小，一般为1460比特。换算成字节，也就是180多字节。

TCP为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了之后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制，来接收数据。

发生TCP粘包、拆包主要是由于下面一些原因：

①应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。

②应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。

③进行mss（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>mss的时候将发生拆包。

④接收方法不及时读取套接字缓冲区数据，这将发生粘包。

**3.如何解决拆包粘包**

既然知道了tcp是无界的数据流，且协议本身无法避免粘包，拆包的发生，那我们只能在应用层数据协议上，加以控制。通常在制定传输数据时，可以使用如下方法：

- 使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。
- 设置定长消息，服务端每次读取既定长度的内容作为一条完整消息。
- 设置消息边界，服务端从网络流中按消息编辑分离出消息内容，如在包尾增加回车或者空格等特殊字符作为分割，典型如FTP。

